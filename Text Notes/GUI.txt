Summary

Keywords
	JavaAWT java.awt - Abstract Windowing Toolkit - until java 1.1
	JavaSwing  javax.swing - The Swing classes are part of a more general set of GUI programming capabilities that are collectively referred to as the Java Foundation Classes
	JFC - Java Foundation Classes - GUI programming capabilities: Swing (javax.swing), 2d drawing (java.awt.geom), drag-and-drop (java.awt.dnd), accessibility (javax.accessibility)
	Event Dispatching Thread - the thread in which all interactions with the GUI are dealt with
	Pluggable Look and Feel - makes it possible to change the appearance of a component, to programmatically select the look-and-feel from those implemented as standard, or create custom
	UIManager, UI Delegate - Swing component provide for plugabble look and feel
	MVC - ModelViewController architecture  
	SMA - Separate Model architecture (Document/View architecture)

Model View Controller (MVC) architecture 
	The MODEL that stores the data that defines the component
	The VIEW that creates the visual representation of the component from the data in the model
	The CONTROLLER that deals with user interaction with the component and modifies the model and/or the view in response to a user action as necessary

Document/View architecture (Separate Model Architecture)
	Because the user interacts with the physical representation of the component, the controller operation is highly dependent on the implementation of the view. 
	For this reason, the view and controller are typically represented by a single composite object that corresponds to a view with an INTEGRATED CONTROLLER. 
	Swing implementation of SMA
	UI Delegate
		The Swing components provide for a pluggable look-and-feel by making the visual appearance of a component and the interface to the user the responsibility of an independent object
		This is the view+controller part of the MVC model. 
		A different UI delegate can provide a component with a new look-and-feel.
		UIManager can set the new look and feel -> UIManager.setLookAndFeel()

Structure
	Object 	<-
			java.awt
			Compontent (abstract) <- Container (abstract) <- Window <- Frame  	<-
																			  	javax.swing
																		   		JFrame 
	Component - Defines a component, which is an entity that can be displayed such as a button or a scrollbar (java.awt)
	Container - Defines a component that can contain other components (java.awt)
	Window - Defines a basic window with no title bar or border (java.awt)
	Frame - Define a window with title bar and border (java.awt)
	JFrame - Defines a frame which is a window with extended capabilities (java.swing)

Components
	A component represents a graphical entity of one kind or another that can be displayed on the screen. A component is any object of a class that is a subclass of Component.
	Component Subclasses summary
		JFrame (javax.swing)
			This is used as the basic Java application window. An object of this class has a title bar and provision for adding a menu. 
			You can also add other components to it. You usually subclass this class to create a window class specific to your application. 
			You then are able to add GUI components or draw in this window if required
		JWindow (javax.swing) 
			An object of this class type is a window with no title bar or window management icons. 
			One typical use for a JWindow object is for a subsidiary application window that is displayed on a secondary display where two or more displays are attached to a system.
		JDialog (javax.swing)
			You use this class to define a dialog window that is used for entering data into a program in various ways. 
			You usually code the creation of a dialog in response to some menu item or button being selected.
		JApplet  (javax.swing)
			This is the base class for a Java 2 applet â€” which is a program designed to run embedded in a web page. 
			All your Java 2 applets have this class as a base. You can draw in a JApplet and also add menus and other components.
		JComponent  (javax.swing)
			The subclasses of JComponent define a range of standard components such as menus, buttons, checkboxes, and so on. You use these classes to create the GUI for your application or applet.

JFrame
	A JFrame object represents the main window for an application (while a Window object does not) â€” you always need a JFrame object before you can create a Window object.
	Because JFrame has Container as a superclass, a JFrame object can contain other components
	The JFrame class adds functionality to the Frame class to support much more sophisticated facilities for drawing and displaying other components
	Display a window with Jframe
		Step 1. Create a JFrame object and set it's properties. 
			It should be in a method to set all relevant properties of the Frame
		Step 2. Create a Runnable class 
			This will call the properties setting method in its run() method
			This class can be an anonymous class inside the invokeLater() method
		Step 3. Call SwingUtilities.invokeLater(new Runnable())
			This will execute the run() method for the Runnable object argument on the event dispatching thread
	Preventing Deadlocks - use the Event Dispatching Thread
		JFrame realization (preparing and setting to visible) should never be done in the main thread.
		After the GUI for an application has been realized by setVisible(true), modifying or querying it on the MAIN thread can cause deadlocks.
		Methods for Swing components are NOT THREAD-SAFE so they must all execute in a separate thread from the main thread
		The thread in which you create the GUI and in which all interactions with the GUI are dealt with is called the SWING EVENT DISPATCHING THREAD. 
	Closing options
		.setDefaultCloseOperations()
			ExitOnClose - closing the window will stop the application (close all other windows)
			DisposeOnClose - when the last JFrame is closed, the application will stop
			DoNothingOnCloes - guess.

JDialog
	Because the JDialog class is derived directly from the Window class, you can create a JDialog object in an application only in the context of a JFrame object.
	Parent of JDialog
		The constructors for the JDialog class generally require a JFrame object to be passed as an argument. 
		This JFrame object is referred to as the parent of the JDialog object. 
	JDialog position
		Because a JFrame object is the top-level window in an application, its size and location are defined relative to the screen. 
		A JDialog object with a JFrame object as a parent is located relative to its parent.
	JDialog as a Container
		The JApplet, JFrame, and JDialog classes are all containers because they have Container as a base class and therefore, in principle, can contain any kind of component.
		You DON'T ADD the components for your application or applet GUI directly to the JFrame or JApplet object for your program.

Window Panes
	When you want to add GUI components or draw in a window displayed from a JFrame object, you add the components to, or draw on, a WINDOW PANE that is managed by the JFrame object. 
	Window Panes are container objects that represent an area of a window, and they come in several different types.
	All the classes here that represent panes are themselves Swing components, defined in the javax.swing package
	Root Pane
		Corresponds
			The area of the window below the title bar 
		Method: .getRootPane()
		Return type: JRootPane
	Layered Pane
		Corresponds
			This pane corresponds to the whole of the area occupied by the JRootPane object in the window and manages the menu bar if the window has one
		Method: .getLayeredPane()
		Return type: JLayeredPane
	Content Pane
		Corresponds
			The area in the layeredPane below the menu bar corresponds to the contentPane object
			The contentPane is where you normally add components other than a menubar to a window. 
		Method: .getContentPane()
		Return type: Container
	Glass Pane
		Corresponds
			The complete JRootPane area on top o f all the other planes
			This is used to display components that you always want to display on top of anything else displayed in the window
			Examples:
				Drop-down menus
				Animations - When part of what is displayed is to be animated, a static background can be displayed independently via the contentPane. 
		Method: .getGlassPane()
		Return type:  Component

AWT Components
	Parent Component
		When a component is contained within another component, the outer object is referred to as the parent.
		getParent() 
			The method is inherited from Component class.
			It returns a reference of the parent object as a type of CONTAINER.
			Only a subclass of Container can hold other components.
		If there is no parent, as is the case with a JFrame component, this method returns null.
	AWT Components
		Name
			java.awt.Name
			The name of the component (This is not the same as the Window title!!)
		Dimension 
			java.awt.Dimension
			The width and height of the component. Variables are private, so getter and setter methods to be used
			Size - Height and Size - Dimension
				.setWidth() / .setWidth()
				.getHeight() / .getHeight()
				.getMinimumSize() / .setMinimumSize();
				.setPreferredSize();
			Dimension windowSize = window.getSize();
		Position 
			java.awt.Point
			The position of X, Y of the component. This fixes where the object is IN RELATION TO ITS CONTAINER in the coordinate system of the container object.
			Variables are private, so getter and setter methods to be used
			Methods
				.get
			Center position
				Set a window to the center location:
					aWindow.setLocationRelativeTo(null); // If the argument is null, it will be centered
				Get the position of center location:
					Point centerPoint = GraphicsEnvironment.getLocalGraphicsEnvironment().getCenterPoint();
			Toolkit
				.getToolkit() method returns an object of type Toolkit that contains information about the environment in which your application is running, including the screen size in pixels. 
			Example
				Point windowPosition = window.getLocation();
				System.out.printf("PosX: %f, PosY: %f%n", windowPosition.getX(), windowPosition.getY());
				window.getToolkit().getScreenSize();
		Rectangle 
			java.awt.Rectangle
			Top left XY position and Size and Height
			Example
				Rectangle windowPositionAndSize = window.getBounds();	//get a Rectangle object based on window
			Methods to manipulate rectangles
				r1.union(r2)
					Returns the smallest Rectangle object enclosing both the current Rectangle object and the Rectangle object r, passed as an argument.
				r1.intersection(r2)
					 Returns a Rectangle object that is the intersection of the current object and the argument. 
					 If the two rectangles do not intersect, the Rectangle object returned is at position (0,0), and the width and height members are zero, so the rectangle is empty
					 .intersects() returns true if the two rectangles intersect
				r1.add()
					.add(Rectangle r)
						Expands the current Rectangle object to enclose the argument Rectangle.  
					.add(Point p)
						Expands the current Rectangle object to enclose the Point object p. The result is the smallest rectangle that encloses the original rectangle and the point.
					.add(int x, int y)
						Expands the current Rectangle object to enclose the point at (x, y)
				r1.grow()
					void grow(int h, int v): Enlarges the current Rectangle object by moving the boundary out from the center by h horizontally and v vertically
				r1.contains() - Returns true if the current Rectangle object encloses p and returns false otherwise.
				r1.equals()- The two rectangles are equal if they are at the same position and have the same width and height.
				r1.isEmpty() - Returns true if the width and height members of the current Rectangle object are zero and returns false otherwise.
		Color
			java.awt.Color
			The three arguments to the constructor correspond to the intensities of the red, green, and blue components of the color, respectively. 
			The Color class defines a number of standard color constants as public final static variables
			Get a color
				.getRGB, .getREd(), getGreen(), .getBlue()
			To set background/foreground, itneeds to be set on the ContentPanek
			SystemColor
				java.awt.SystemColor
				The SystemColor is a subclass of Color and encapsulates the standard colors that the native operating system uses for displaying various components. 
					window 			- Defines the background color for a window
					windowText 		- Defines the text color for a window
					windowBorder 	. Defines the border color for a window
			Examples
				Color myColor = new Color(0,200,0)
				aWindow.getContentPane().setBackground(Color.RED);
				aWindow.getContentPane().setBackground(myColor);
				if(myColor.getRGB() == SystemColor.window.getRGB()) { // colorA is the window background color...  }
		Cursor
			java.awt.Cursor 
			An object of the java.awt.Cursor class encapsulates a bitmap representation of the mouse cursor. 
			The Cursor class contains a range of final static constants that specify standard cursor types
			Static method .getPredefinedCursor
				This method is particularly useful when you don't want to store the Cursor object, but just want to pass it to a method, such as setCursor() for a Component object.
			Custom cursor
				The createCustomCursor() method for a Toolkit object enables you to create a cursor.
				Need to provide the cursor image, the coordinates of the cursor hotspot and the cursor name.
			Examples
				Cursor myCursor = new Cursor(Cursor.TEXT_CURSOR);
				Cursor myCursor = Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR);
		Font
			java.awt.Font
			Fonts vs. Glyps vs. Character
				The Font class differentiates between a character — the letter uppercase Q, say — and a glyph, which is the shape defining its appearance when it is displayed or printed. 
				In general, a given character in one font has a different glyph in a different font.
				A Font object contains a table that maps the Unicode value for each character to the glyph code or codes that create the visual representation of the character.
			Logical Fonts
				Logical fonts are five families of fonts defined by the Java platform and are therefore supported in any Java runtime. 
				Style
					Plain, Bold, Italic
				Types
					Serif, Dialog, DialogInput, Monospaced, SansSerif
			Physical Fonts
				Get all Fonts (slow)
					GraphicsEnvironment e = GraphicsEnvironment.getLocalGraphicsEnvironment();
					Font[] fonts = e.getAllFonts(); 
				Get all FontNames (faster)
					GraphicsEnvironment e = GraphicsEnvironment.getLocalGraphicsEnvironment();
					String[] fontnames = e.getAvailableFontFamilyNames();
			Create Font object
				Font myFont = new Font(“Serif”, Font.ITALIC | Font.BOLD, 12);	 //Bold AND Italic
			.deriveFont()
				Font deriveFont(int Style): Returns a new Font object with the style specified — one of PLAIN, BOLD, ITALIC, or BOLD+ITALIC.
				Font deriveFont(float size): Returns a new Font object with the specified point size.
				Font deriveFont(int Style, float size): Returns a new Font object with the specified style and point size.
				Example
					Font newFont = fonts[fonts.length-1].deriveFont(12.0f)
		Visible
			If not visible, it is not drawn
		Enabled 
			If diabled, it is grayed out, but still can originate events
			To prevent events from a disabled component having an effect, you must call isEnabled() for the component in your event handling code to determine whether the component is enabled or not. 
			You can then choose to do nothing when the isEnabled() method returns false.
		Valid 
			If an object is not valid, the layout of the entities that make up the object has not been determined.  
			You can make a Container object invalid by changing its contents. 
			It then needs to be validated before it is displayed correctly	

Swing Components 
	JComponent
		Swing components all have the JComponent class as a base, which itself extends the Component class to add the following capability:
			Support for pluggable look-and-feel for components, allowing you to change the look-and-feel programmatically, or implement your own look-and-feel for all components displayed.
			Support for tooltips — a tooltip being a message describing the purpose of a component when the mouse cursor lingers over it. Tooltips are defined by the JToolTip class.
			Support for automatic scrolling in a list, a table, or a tree when a component is dragged with the mouse.
			Component class extensions to enable you to create your own custom components.
		All the Swing component classes are defined in the javax.swing package and have class names that begin with J.
	Buttons
		All the buttons can be displayed with a text label, an icon, or both.
		JButton
			The JButton class defines a regular pushbutton that can be used in a regular dialog box or in a toolbar, where the buttons might provide alternatives to using menu items. 
		JToolBar
			The JToolBar class is used in conjunction with the JButton class to create a toolbar containing buttons. 
			A toolbar is dockable without any additional programming effort on your part.
		JToggleButton
			Two-state button, pressed or not
			JRadioButton (ButtonGroup)
				Radio buttons defined as JRadioButton objects generally operate in a group so that only one button can be in the pressed state at any one time. 
				This grouping is established by adding the JRadioButton object to a ButtonGroup object that takes care of the state of the buttons in the group.
		JCheckbox
			A JCheckBox object is a button with a square checkbox to the left. Clicking on the checkbox changes its state from checked to unchecked or vice versa.
	Menus
		JMenuBar
			The JMenuBar class defines a menu bar usually found at the top of an application window.
		JPopupMenu
			 The JPopupMenu class defines a context menu that is typically implemented to appear at the current cursor position when the right mouse button is clicked. 
		JMenuItem
			The items in a menu are defined by the JMenuItem class.
			JMenu
				A JMenu object represents a TOP-LEVEL MENU ITEM on a menu bar that drops down a list of menu items when it is clicked. 
			JRadioButtonMenuItem (ButtonGroup)
				The JRadioButtonMenuItem class defines a menu item that is part of a group where only one item can be selected at any time. 
				The group is created by adding JRadioButtonMenuItem objects to a ButtonGroup object. 
			JCheckBoxMenuItem
				A JCheckBoxMenuItem component is a menu item with a checkbox that is ticked when the item is selected.
				LIne
	Text
		JLabel
			Non-editable single line of text
		JTextField
			Editable single line of text
		JFormattedTextField
			Editable text field where input and displayed data can be formatted. Supports automatic formattig, for entering a Date for example
		JPasswordField
			Enter a single line of passwords with entered characters not being seen
		JTextArea (JScrollPane container)
			Editable mulitline text that is contained within a given area. 
			A JTextArea component does not support scrolling directly, but it's easy to add scrollbars by placing the JTextArea component in a JScrollPane container.
		JEditorPane
			The JEditorPane supports editing of plaintext, text in HTML, and RTF (Rich Text Format). 
		JTextPane
			The JTextPane class extends JEditorPane and enables you to embed images or other components within the text managed by the component.
	JPanel
		The JPanel class defines something like a physical panel that you can use as a container to group a set of components
	JList
		A JList<E> component displays a list of items of type E with one item per line from which a user can select an item.
		Creating a JList<E> component from from a javax.swing.DefaultListModel<E> object in which you store the items you want to have displayed in the list. 
		A DefaultListModel<> object is much like a vector<> container. You add items to the list model by calling the addElement().
	JTable
		A JTable component displays items in a rectangular table with column headers with the items stored in a table model. 
		You can create your own table model class by using the javax.swing.table.AbstractTableModel class as a base. 
		A user can edit a single cell, or relocate or delete an entire row or column. 
		A JTable component automatically takes care of reordering the columns when a column is dragged to a new position using the mouse.


			

























Source
	Horton, Chapter 17, p661

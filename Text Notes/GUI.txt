Summary

Keywords
	JavaAWT java.awt - Abstract Windowing Toolkit - until java 1.1
	JavaSwing  javax.swing - The Swing classes are part of a more general set of GUI programming capabilities that are collectively referred to as the Java Foundation Classes
	JFC - Java Foundation Classes - GUI programming capabilities: Swing (javax.swing), 2d drawing (java.awt.geom), drag-and-drop (java.awt.dnd), accessibility (javax.accessibility)
	Event Dispatching Thread - the thread in which all interactions with the GUI are dealt with
	Pluggable Look and Feel - makes it possible to change the appearance of a component, to programmatically select the look-and-feel from those implemented as standard, or create custom
	UIManager, UI Delegate - Swing component provide for plugabble look and feel
	MVC - ModelViewController architecture  
	SMA - Separate Model architecture (Document/View architecture)

Model View Controller (MVC) architecture 
	The MODEL that stores the data that defines the component
	The VIEW that creates the visual representation of the component from the data in the model
	The CONTROLLER that deals with user interaction with the component and modifies the model and/or the view in response to a user action as necessary

Document/View architecture (Separate Model Architecture)
	Because the user interacts with the physical representation of the component, the controller operation is highly dependent on the implementation of the view. 
	For this reason, the view and controller are typically represented by a single composite object that corresponds to a view with an INTEGRATED CONTROLLER. 
	Swing implementation of SMA
	UI Delegate
		The Swing components provide for a pluggable look-and-feel by making the visual appearance of a component and the interface to the user the responsibility of an independent object
		This is the view+controller part of the MVC model. 
		A different UI delegate can provide a component with a new look-and-feel.
		UIManager can set the new look and feel -> UIManager.setLookAndFeel()

Structure
	Object 	<-
			java.awt
			Compontent (abstract) <- Container (abstract) <- Window <- Frame  	<-
																			  	javax.swing
																		   		JFrame 
	Component - Defines a component, which is an entity that can be displayed such as a button or a scrollbar (java.awt)
	Container - Defines a component that can contain other components (java.awt)
	Window - Defines a basic window with no title bar or border (java.awt)
	Frame - Define a window with title bar and border (java.awt)
	JFrame - Defines a frame which is a window with extended capabilities (java.swing)

Components
	A component represents a graphical entity of one kind or another that can be displayed on the screen. A component is any object of a class that is a subclass of Component.
	Component Subclasses summary
		JFrame (javax.swing)
			This is used as the basic Java application window. An object of this class has a title bar and provision for adding a menu. 
			You can also add other components to it. You usually subclass this class to create a window class specific to your application. 
			You then are able to add GUI components or draw in this window if required
		JWindow (javax.swing) 
			An object of this class type is a window with no title bar or window management icons. 
			One typical use for a JWindow object is for a subsidiary application window that is displayed on a secondary display where two or more displays are attached to a system.
		JDialog (javax.swing)
			You use this class to define a dialog window that is used for entering data into a program in various ways. 
			You usually code the creation of a dialog in response to some menu item or button being selected.
		JApplet  (javax.swing)
			This is the base class for a Java 2 applet â€” which is a program designed to run embedded in a web page. 
			All your Java 2 applets have this class as a base. You can draw in a JApplet and also add menus and other components.
		JComponent  (javax.swing)
			The subclasses of JComponent define a range of standard components such as menus, buttons, checkboxes, and so on. You use these classes to create the GUI for your application or applet.

JFrame
	A JFrame object represents the main window for an application (while a Window object does not) â€” you always need a JFrame object before you can create a Window object.
	Because JFrame has Container as a superclass, a JFrame object can contain other components
	The JFrame class adds functionality to the Frame class to support much more sophisticated facilities for drawing and displaying other components
	Display a window with Jframe
		Step 1. Create a JFrame object and set it's properties. 
			It should be in a method to set all relevant properties of the Frame
		Step 2. Create a Runnable class 
			This will call the properties setting method in its run() method
			This class can be an anonymous class inside the invokeLater() method
		Step 3. Call SwingUtilities.invokeLater(new Runnable())
			This will execute the run() method for the Runnable object argument on the event dispatching thread
	Preventing Deadlocks - use the Event Dispatching Thread
		JFrame realization (preparing and setting to visible) should never be done in the main thread.
		After the GUI for an application has been realized by setVisible(true), modifying or querying it on the MAIN thread can cause deadlocks.
		Methods for Swing components are NOT THREAD-SAFE so they must all execute in a separate thread from the main thread
		The thread in which you create the GUI and in which all interactions with the GUI are dealt with is called the SWING EVENT DISPATCHING THREAD. 
	Closing options
		.setDefaultCloseOperations()
			ExitOnClose - closing the window will stop the application (close all other windows)
			DisposeOnClose - when the last JFrame is closed, the application will stop
			DoNothingOnCloes - guess.

JDialog
	Because the JDialog class is derived directly from the Window class, you can create a JDialog object in an application only in the context of a JFrame object.
	Parent of JDialog
		The constructors for the JDialog class generally require a JFrame object to be passed as an argument. 
		This JFrame object is referred to as the parent of the JDialog object. 
	JDialog position
		Because a JFrame object is the top-level window in an application, its size and location are defined relative to the screen. 
		A JDialog object with a JFrame object as a parent is located relative to its parent.
	JDialog as a Container
		The JApplet, JFrame, and JDialog classes are all containers because they have Container as a base class and therefore, in principle, can contain any kind of component.
		You DON'T ADD the components for your application or applet GUI directly to the JFrame or JApplet object for your program.

Window Panes
	When you want to add GUI components or draw in a window displayed from a JFrame object, you add the components to, or draw on, a WINDOW PANE that is managed by the JFrame object. 
	Window Panes are container objects that represent an area of a window, and they come in several different types.
	All the classes here that represent panes are themselves Swing components, defined in the javax.swing package
	Root Pane
		Corresponds
			The area of the window below the title bar 
		Method: .getRootPane()
		Return type: JRootPane
	Layered Pane
		Corresponds
			This pane corresponds to the whole of the area occupied by the JRootPane object in the window and manages the menu bar if the window has one
		Method: .getLayeredPane()
		Return type: JLayeredPane
	Content Pane
		Corresponds
			The area in the layeredPane below the menu bar corresponds to the contentPane object
			The contentPane is where you normally add components other than a menubar to a window. 
		Method: .getContentPane()
		Return type: Container
	Glass Pane
		Corresponds
			The complete JRootPane area on top o f all the other planes
			This is used to display components that you always want to display on top of anything else displayed in the window
			Examples:
				Drop-down menus
				Animations - When part of what is displayed is to be animated, a static background can be displayed independently via the contentPane. 
		Method: .getGlassPane()
		Return type:  Component

AWT Components
	Parent Component
		When a component is contained within another component, the outer object is referred to as the parent.
		getParent() 
			The method is inherited from Component class.
			It returns a reference of the parent object as a type of CONTAINER.
			Only a subclass of Container can hold other components.
		If there is no parent, as is the case with a JFrame component, this method returns null.
	AWT Components
		Name
			java.awt.Name
			The name of the component (This is not the same as the Window title!!)
		Dimension 
			java.awt.Dimension
			The width and height of the component. Variables are private, so getter and setter methods to be used
			Size - Height and Size - Dimension
				.setWidth() / .setWidth()
				.getHeight() / .getHeight()
				.getMinimumSize() / .setMinimumSize();
				.setPreferredSize();
			Dimension windowSize = window.getSize();
		Position 
			java.awt.Point
			The position of X, Y of the component. This fixes where the object is IN RELATION TO ITS CONTAINER in the coordinate system of the container object.
			Variables are private, so getter and setter methods to be used
			Methods
				.get
			Center position
				Set a window to the center location:
					aWindow.setLocationRelativeTo(null); // If the argument is null, it will be centered
				Get the position of center location:
					Point centerPoint = GraphicsEnvironment.getLocalGraphicsEnvironment().getCenterPoint();
			Toolkit
				.getToolkit() method returns an object of type Toolkit that contains information about the environment in which your application is running, including the screen size in pixels. 
			Example
				Point windowPosition = window.getLocation();
				System.out.printf("PosX: %f, PosY: %f%n", windowPosition.getX(), windowPosition.getY());
				window.getToolkit().getScreenSize();
		Rectangle 
			java.awt.Rectangle
			Top left XY position and Size and Height
			Example
				Rectangle windowPositionAndSize = window.getBounds();	//get a Rectangle object based on window
			Methods to manipulate rectangles
				r1.union(r2)
					Returns the smallest Rectangle object enclosing both the current Rectangle object and the Rectangle object r, passed as an argument.
				r1.intersection(r2)
					 Returns a Rectangle object that is the intersection of the current object and the argument. 
					 If the two rectangles do not intersect, the Rectangle object returned is at position (0,0), and the width and height members are zero, so the rectangle is empty
					 .intersects() returns true if the two rectangles intersect
				r1.add()
					.add(Rectangle r)
						Expands the current Rectangle object to enclose the argument Rectangle.  
					.add(Point p)
						Expands the current Rectangle object to enclose the Point object p. The result is the smallest rectangle that encloses the original rectangle and the point.
					.add(int x, int y)
						Expands the current Rectangle object to enclose the point at (x, y)
				r1.grow()
					void grow(int h, int v): Enlarges the current Rectangle object by moving the boundary out from the center by h horizontally and v vertically
				r1.contains() - Returns true if the current Rectangle object encloses p and returns false otherwise.
				r1.equals()- The two rectangles are equal if they are at the same position and have the same width and height.
				r1.isEmpty() - Returns true if the width and height members of the current Rectangle object are zero and returns false otherwise.
		Color
			java.awt.Color
			The three arguments to the constructor correspond to the intensities of the red, green, and blue components of the color, respectively. 
			The Color class defines a number of standard color constants as public final static variables
			Get a color
				.getRGB, .getREd(), getGreen(), .getBlue()
			To set background/foreground, itneeds to be set on the ContentPanek
			SystemColor
				java.awt.SystemColor
				The SystemColor is a subclass of Color and encapsulates the standard colors that the native operating system uses for displaying various components. 
					window 			- Defines the background color for a window
					windowText 		- Defines the text color for a window
					windowBorder 	. Defines the border color for a window
			Examples
				Color myColor = new Color(0,200,0)
				aWindow.getContentPane().setBackground(Color.RED);
				aWindow.getContentPane().setBackground(myColor);
				if(myColor.getRGB() == SystemColor.window.getRGB()) { // colorA is the window background color...  }
		Cursor
			java.awt.Cursor 
			An object of the java.awt.Cursor class encapsulates a bitmap representation of the mouse cursor. 
			The Cursor class contains a range of final static constants that specify standard cursor types
			Static method .getPredefinedCursor
				This method is particularly useful when you don't want to store the Cursor object, but just want to pass it to a method, such as setCursor() for a Component object.
			Custom cursor
				The createCustomCursor() method for a Toolkit object enables you to create a cursor.
				Need to provide the cursor image, the coordinates of the cursor hotspot and the cursor name.
			Examples
				Cursor myCursor = new Cursor(Cursor.TEXT_CURSOR);
				Cursor myCursor = Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR);
		Font
			java.awt.Font
			Fonts vs. Glyps vs. Character
				The Font class differentiates between a character — the letter uppercase Q, say — and a glyph, which is the shape defining its appearance when it is displayed or printed. 
				In general, a given character in one font has a different glyph in a different font.
				A Font object contains a table that maps the Unicode value for each character to the glyph code or codes that create the visual representation of the character.
			Logical Fonts
				Logical fonts are five families of fonts defined by the Java platform and are therefore supported in any Java runtime. 
				Style
					Plain, Bold, Italic
				Types
					Serif, Dialog, DialogInput, Monospaced, SansSerif
			Physical Fonts
				Get all Fonts (slow)
					GraphicsEnvironment e = GraphicsEnvironment.getLocalGraphicsEnvironment();
					Font[] fonts = e.getAllFonts(); 
				Get all FontNames (faster)
					GraphicsEnvironment e = GraphicsEnvironment.getLocalGraphicsEnvironment();
					String[] fontnames = e.getAvailableFontFamilyNames();
			Create Font object
				Font myFont = new Font(“Serif”, Font.ITALIC | Font.BOLD, 12);	 //Bold AND Italic
			.deriveFont()
				Font deriveFont(int Style): Returns a new Font object with the style specified — one of PLAIN, BOLD, ITALIC, or BOLD+ITALIC.
				Font deriveFont(float size): Returns a new Font object with the specified point size.
				Font deriveFont(int Style, float size): Returns a new Font object with the specified style and point size.
				Example
					Font newFont = fonts[fonts.length-1].deriveFont(12.0f)
		Visible
			If not visible, it is not drawn
		Enabled 
			If diabled, it is grayed out, but still can originate events
			To prevent events from a disabled component having an effect, you must call isEnabled() for the component in your event handling code to determine whether the component is enabled or not. 
			You can then choose to do nothing when the isEnabled() method returns false.
		Valid 
			If an object is not valid, the layout of the entities that make up the object has not been determined.  
			You can make a Container object invalid by changing its contents. 
			It then needs to be validated before it is displayed correctly	

Swing Components 
	JComponent
		Swing components all have the JComponent class as a base, which itself extends the Component class to add the following capability:
			Support for pluggable look-and-feel for components, allowing you to change the look-and-feel programmatically, or implement your own look-and-feel for all components displayed.
			Support for tooltips — a tooltip being a message describing the purpose of a component when the mouse cursor lingers over it. Tooltips are defined by the JToolTip class.
			Support for automatic scrolling in a list, a table, or a tree when a component is dragged with the mouse.
			Component class extensions to enable you to create your own custom components.
		All the Swing component classes are defined in the javax.swing package and have class names that begin with J.
	Buttons
		All the buttons can be displayed with a text label, an icon, or both.
		JButton
			The JButton class defines a regular pushbutton that can be used in a regular dialog box or in a toolbar, where the buttons might provide alternatives to using menu items. 
			.setPreferredSize(Dimension) - sets the size (widht, height) for the button object
		JToolBar
			The JToolBar class is used in conjunction with the JButton class to create a toolbar containing buttons. 
			A toolbar is dockable without any additional programming effort on your part.
		JToggleButton
			Two-state button, pressed or not
			JRadioButton (ButtonGroup)
				Radio buttons defined as JRadioButton objects generally operate in a group so that only one button can be in the pressed state at any one time. 
				This grouping is established by adding the JRadioButton object to a ButtonGroup object that takes care of the state of the buttons in the group.
			JCheckbox
				A JCheckBox object is a button with a square checkbox to the left. Clicking on the checkbox changes its state from checked to unchecked or vice versa.
		ButtonGroup object
			The ButtonGroup object tracks the state of all of the buttons in the group. 
			When any button is turned on, all the others are turned off, so only one button in the group can be on at one time
			Only one button can be selected from the buttons(checkboxes, radiobuttons) that are added to a ButtonGroup
			Example:
				ButtonGroup checkboxGroup = new ButtonGroup();
				checkBoxGroup.add(checkboxitem1);
				checkBoxGroup.add(checkboxitem2);
	Menus
		JMenuBar
			The JMenuBar class defines a menu bar usually found at the top of an application window.
		JPopupMenu
			 The JPopupMenu class defines a context menu that is typically implemented to appear at the current cursor position when the right mouse button is clicked. 
		JMenuItem
			The items in a menu are defined by the JMenuItem class.
			JMenu
				A JMenu object represents a TOP-LEVEL MENU ITEM on a menu bar that drops down a list of menu items when it is clicked. 
			JRadioButtonMenuItem (ButtonGroup)
				The JRadioButtonMenuItem class defines a menu item that is part of a group where only one item can be selected at any time. 
				The group is created by adding JRadioButtonMenuItem objects to a ButtonGroup object. 
			JCheckBoxMenuItem
				A JCheckBoxMenuItem component is a menu item with a checkbox that is ticked when the item is selected.
				LIne
	Text
		JLabel
			Non-editable single line of text
		JTextField
			Editable single line of text
		JFormattedTextField
			Editable text field where input and displayed data can be formatted. Supports automatic formattig, for entering a Date for example
		JPasswordField
			Enter a single line of passwords with entered characters not being seen
		JTextArea (JScrollPane container)
			Editable mulitline text that is contained within a given area. 
			A JTextArea component does not support scrolling directly, but it's easy to add scrollbars by placing the JTextArea component in a JScrollPane container.
		JEditorPane
			The JEditorPane supports editing of plaintext, text in HTML, and RTF (Rich Text Format). 
		JTextPane
			The JTextPane class extends JEditorPane and enables you to embed images or other components within the text managed by the component.
	JPanel
		The JPanel class defines something like a physical panel that you can use as a container to group a set of components
	JList
		A JList<E> component displays a list of items of type E with one item per line from which a user can select an item.
		Creating a JList<E> component from from a javax.swing.DefaultListModel<E> object in which you store the items you want to have displayed in the list. 
		A DefaultListModel<> object is much like a vector<> container. You add items to the list model by calling the addElement().
	JTable
		A JTable component displays items in a rectangular table with column headers with the items stored in a table model. 
		You can create your own table model class by using the javax.swing.table.AbstractTableModel class as a base. 
		A user can edit a single cell, or relocate or delete an entire row or column. 
		A JTable component automatically takes care of reordering the columns when a column is dragged to a new position using the mouse.

Swing Containers
	All Swing Components are Containers
		Because the Container class is an abstract class, you cannot create instances of Container.
		The components within a container are displayed within the area occupied by the container on the display screen
		The container also controls how its embedded components are laid out by means of an object called a layout manager.
	Container Methods
		int getComponentCount() 			- Returns a count of the number of components contained by the current container.
		Component getComponent(int index) 	- Returns the component identified by the index value (0-one less than the nomber of components contained).
		Component[] getComponents() 		- Returns an array of all the components in the current container

Layout Managers
	Overview of Layout Managers
		The layout manager for a container determines the position and size of all the components in the container.
		Layout managers automatically adjust the size and positions of components to fi t within the space available. 
		All containers have a default layout manager, but you can choose a different layout manager when necessary
		Because the classes that define layout managers all implement the LayoutManager interface, you can use a variable of type LayoutManager to reference any of them.
	Set Gaps
		set the gaps in constructor -> .getHGap()/setHGap() and .getVGap()  / .setVGap()
		layoutObject.setVGap()
		layoutObject.setHGap()
	Set Borders
		Create Border objects
			EtchedBorder edge = new EtchedBorder(EtchedBorder.RAISED);
			BevelBorder edge = new BevelBorder(BevelBorder.RAISED); 
			Border edge = BorderFactory.createRaisedBevelBorder();					//Using BorderFactory class's static factory methods 
			Border doubleBorder = new CompoundBorder(outerBorder, innerBorder);		//First argument: outer border, second argument: inner border	
			Border lineBorder = BorderFactory.createLineBorder(Color.Black, 12) 	//Line with color, and size in pixel
			Border blackLineBorder = BorderFactory.createBlackLineBorder()
		Set the border for a Button
			content.add(button = new JButton("EAST Border Button"), BorderLayout.EAST);
			button.setBorder(edge);
    		leftPanel.setBorder(new TitledBorder( new EtchedBorder(),  "Line Color"));     

   			bottomPanel.setBorder(new CompoundBorder(
        	BorderFactory.createLineBorder(Color.black, 1),             // Outer border
          	BorderFactory.createBevelBorder(BevelBorder.RAISED)));      // Inner border
			
	.pack() method
		 Causes this Window to be sized to fit the preferred size and layouts of its subcomponents. 
		 To make the window ssume a size that just accommodates the components it contains, call the pack() method on the JFrame.
	Overview of Layout Managers
		FlowLayout	
			FlowLayout places components in successive rows in a container, fitting as many on each row as possible and starting on the next row as soon as a row is full. 
			Its primary use is for arranging buttons, although you can use it with other components. 
			It is the default layout manager for JPanel objects.
		BorderLayout
			BorderLayout places components against any of the four borders of the container and in the center.
			The component in the center fills the available space. 
			This layout manager is the default for the content pane in a JFrame, JDialog, or JApplet object.
		CardLayout
			CardLayout places components in a container one on top of the other — like a deck of cards.
			Only the "top" component is visible at any one time.
		GridLayout
			GridLayout places components in the container in a rectangular grid with the number of rows and columns that you specify.
		GridBagLayout
			GridBagLayout also places the components into an arrangement of rows and columns, but the rows and columns can vary in length. 
			This is a complicated layout manager with a lot of flexibility in how you control where components are placed in a container.
		BoxLayout
			BoxLayout arranges components either in a row or in a column. 
			In either case the components are clipped to fit if necessary, rather than wrapping to the next row or column. 
			The BoxLayout manager is the default for the Box container class.
		SpringLayout
			SpringLayout allows components to have their positions defined by "springs" or "struts" fixed to an edge of the container or other components in the container.
	Create and set a layout manager
		1. Create LayoutManager object
			FlowLayout flow = new FlowLayout();
		2. Get the Content Pane of frame
			Container content = aWindow.getContentPane();               // Get the content pane
		3. Set the layout of the content pane
			content.setLayout(flow);                                    // Set the container layout mgr
			bWindow.getContentPane().setLayout(flow);					//Set the container layout mgr directly
	FlowLayout
		The flow layout manager places components in a row, and when the row is full, it automatically spills components onto the next row. 
		Defaults
			Default positioning: CENTERED
			Default orientation: left to right
			Default component distance: 5 unit gap
			default row distance: 5 unit gap (even from the top)
		Example	
			FlowLayout flow = new FlowLayout(FlowLayout.LEFT, 20, 30); //left alignment, horizontal gap, vertical gap
			flow.setHgap(30)
			flow.setVGap(40)
	BorderLayout
		The border layout manager is intended to place up to FIVE components in a container. 
		With this layout manager you can place components on any of the four borders of the container and in the center. 
		Only one component can be at each position. 
		If you add a component at a position that is already occupied, the previous component is displaced. 
		A border is selected by specifying a constraint that can be NORTH, SOUTH, EAST, WEST, or CENTER. 
		You can't specify the constraints in the BorderLayout constructor because a different constraint has to be applied to each component. 
		You specify the position of each component in a container when you add it using the add() method. 
		Gaps
			You can alter the spacing between components by passing arguments to the BorderLayout constructor — the default gaps are zero. 
		Example
			BorderLayout border = new BorderLayout();                          // Create a layout manager
			Container content = aWindow.getContentPane();                      // Get the content pane
			content.setLayout(border); 
			EtchedBorder edge = new EtchedBorder(EtchedBorder.RAISED);         // Button border
			JButton button;
			content.add(button = new JButton("EAST Border Button"), BorderLayout.EAST);
			button.setBorder(edge);
	CardLayout
		The card layout manager generates a stack of components, one on top of the other. 
		The first component that you add to the container is at the top of the stack, and therefore visible, and the last one is at the bottom.
		Using card layout requires that you identify each component by an object of some class type 
		and you supply this via the second argument to the add() method — the method parameter is of type Object. 
		Note: NOT the card ID will be displayed, but the button label
		Example
			pass a String object as the second argument to the add() method consisting of the string “Card” with the sequence number of the button appended to it.
			content.add(button = new JButton(" Press ", "CardIdentifier");   
			card.show(content, "CardIdentifier");                       
	GridLayout
		If you specify the number of rows/columns as zero, the layout manager provides as many rows/columns in the grid as are necessary to accommodate the number of components
		If you fix both the rows and the columns, and add more components to the container than the grid accommodates, the number of columns is increased.
		Example
			GridLayout grid = new GridLayout( int rows,int cols,int hgap,int vgap);
	BoxLayout
		The javax.swing.BoxLayout class defines a layout manager that arranges components in either a SINGLE row or a single column. 
		Components are added from left to right in a row, or from top to bottom in a column. 
		Components in a given row or column do not spill onto the next row or column when the row or column is full. 
		The layout manager reduces the size of the components or even clips them if necessary to keep them all in a single row or column. 
		Example:
			Box fullContentBox=Box.createVerticalBox();
			fullContentBox.add(topPanel);
			fullContentBox.add(bottomPanel);
	GridBAGLayout
		General
			Arranges components in an arbitrary rectangular grid, but the rows and columns of the grid are not necessarily the same height or width	
			A component is placed at a given cell position in the grid specified by the coordinates of the cell.
			Top-left corner is at position (0,0). 
			A component can be spread over several cells in a row and/or column in the grid, but a component always occupies a rectangular group of cells.
		Skeleton
			1. Create jFrame
				JFrame mainFrame = new JFrame();
			2. Create GridBagLayout object
				GridBagLayout gridBagLayout=new GridBagLayout();
			3. Set jFrame's Content Pane layout to GridBagLayout 
				mainFrame.getContentPane().setLayout(gridBagLayout);
			4. (optional) Create GridBagConstraints object
				GridBagConstraints gridBagLayoutConstraints = new GridBagConstraints(); 
			5. Create Components and add to content pane
			6. (optional) set constraints for Components
		Constraints
			Each component in a GridBagLayout has its own set of constraints. 
			These are defined by an object of type GridBagConstraints that you associate with each component BEFORE adding the component to the container.
				Example:
					gridBagLayoutObject.setConstraints(componentObject, gridBagConstraintsObject);
			Setting A Constraint
				Set the value of one of the instance variables
				When setConstraints() is called to associate the GridBagConstraints object with a component object
					It CREATES A COPY OF THE CONSTRAINTS OBJECT that was passed as the argument 
					AND a reference to the copy is stored in the layout not a reference to the object that you created.
				This enables to change the constraints object to use it for another component without affecting the constraints for the first.
				Example:
					gridBagConstraintsObject.fill = GridBagConstraints.BOTH				//GridBagConstraints class has constants for values that can be used for instance variables
			Instance Variables of GridBagConstraints
				gridx and gridy  - POSITION
					Determines the position of the component in the container as coordinate positions of cells in the grid, where (0,0) is the top-left position in the grid.
					The position of a component is defining where the top-left cell that it occupies is.
					Either relative to the grid origin or relative to the last component that was added to the container.
					Default: RELATIVE
						GridBagContstraints.REALATIVE - places top-left grid position for the component in the column immediately to the right of the previous component. 
				gridwidth and gridheight  - SIZE
					Determines the size of the area occupied by the component in the container.
					The number of cells to be occupied by a component horizontally and vertically 
					Default: 1
					GridBagConstraints.REMAINDER
						makes the component the last one in the row or column and occupies the remaining cells.
					GridBagConstraints.RELATIVE
						the component is the penultimate (utolsó elõtti) one in the row or column.
				weightx and weighty - Available space distribution
					Determines how free space is distributed between components in the container in the horizontal and vertical directions.
					The absolute values for weightx and weighty ar
					If all the values are set to the same (but not zero), the space for each component is distributed uniformly. 
					Space is distributed between components in the proportions defined by the values of weightx and weighty.
					The proportion of the available space that a component gets in the x direction is the weightx value for the component divided by the sum of the weightx values in the row. 
					This also applies to the weighty values for allocating space in the y direction.
					Example
						If three components in a row have weightx values of 1.0, 2.0, and 3.0 (sum of weitghtx=6)
							the first gets 1/6 of the total in the x direction
							the second gets 2/6, which is 1/3, 
							the third gets 3/6, which is half. 
					Default: 0 (components bunched together in the center of the container)
				anchor 
					Determines where a component is positioned within the area allocated to it in the container.
				ipadx and ipady 
					Determines by how much the component size is to be increased above its minimum size.
				fill 
					Determines how the component is to be enlarged to fill the space allocated to it.
				insets 
					Specifies the free space that is to be provided around the component within the space allocated to it in the container.
		Sources on GridBagConstraints
			http://www.java2s.com/Tutorial/Java/0240__Swing/UsingGridBagConstraints.htm
	Spring Layout
		Overview
			Spring Layout determines the position and size of each component in the container according to a set of constraints that are defined by javax.swing.Spring objects. 
			To constrain the location and size of a component, you call methods for the constraints object to set individual constraints.
		Setting up a Spring Layout
			1. Create the Spring Layout object
				SpringLayout layout = new SpringLayout(); 		// Create a layout manager
				Container content = aWindow.getContentPane(); 	// Get the content pane
				content.setLayout(layout);
			2. Add the Component to the Container
				Before you can access the SpringLayout.constraints object for a component object, you must first add the component to the container
				JButton button = new JButton(“Press Me”);
				content.add(button);
			3. Call .getConstraints(Component c)
				Now you can call the getConstraint() method for the SpringLayout object to obtain the object encapsulating the constraints:
				SpringLayout.Constraints constraints = layout.getConstraints(button);
			4. Create Spring object(s)
				Spring spring = Spring.constant(10,100,1000);
			5. Assign the Spring object to Component's Constraints to set their constraints
				constraints.setX(spring)
		Spring Constraints
			The top, bottom, left, and right edges of a component are referred to by their compass points: north, south, west, and east
			X,Y - defines North & West edge
			width, height - defines East & North edges
				East = X+width
				North = Y+height
			The X, Y, width, and height constraints can be set independently and a constraint can set explicitly for any edge.
			If setting values violates the constraints,  the layout manager adjusts one or other of the constraints so that the preceding relationships still apply.
			The SpringLayout manager automatically adds Spring constraints that control the width and height of a component based on the component's minimum, maximum, and preferred sizes.
		Spring Object (not the same as the SpringLayout!)
			The Spring class in the javax.swing package defines the Spring object that represents a constraint. 
			A Spring object is defined by three integer values that relate to the notional (képzeletbeli) length of the spring (rugó):
				the minimum length,
				the preferred length
				the maximum length. 
			A Spring object also has an ACTUAL LENGTH value that lies between the minimum and the maximum, and that determines the location of the edge to which it applies.
			Creating Spring Object - Spring.constant(min, pref, max)
				The static constant() method in the Spring class creates a Spring object from the three arguments that are the minimum, preferred, and maximum values for the Spring object.
				If all three values are equal,the object is called a strut because its value is fixed at the common value you set for all three.
				Example
					Spring spring = Spring.constant(10, 30, 50); 	// min=10, pref=30, max=50
					Spring strut = Spring.constant(40); 			// min, pref, and max all set to 40
				The Spring class also defines static methods that operate on Spring objects:
					Spring sum(Spring spr1, Spring spr2)
						Returns a reference to a new object that has minimum, preferred, and maximum values that are the sum of the corresponding values of the arguments.
					Spring minus(Spring spr)
						Returns a reference to a new object with minimum, preferred, and maximum values that are the same magnitude as those of the argument but with opposite signs.
					Spring max(Spring spr1,Spring spr2)
						Returns a reference to a new object that has minimum, preferred, and maximum values that are the maximum of the corresponding values of the arguments.
				Spring.width(Component c) and Spring.height(Component c)
					Automatically set the width/height for the Spring object based on the component' dimension that was passed as argument
		Setting Constraints with Spring objects for a Component (button)
			.setX()
				Set the WEST(left) edge constraint of the component and the container
			.setY()
				Set the NORTH(top) edge constraint of the component and the container
			.setWidth()
				Set the Width(size, EAST) of the component
			.setHeight()
				Set the Height(size, NORTH) of the component
			.setConstraint()
				Explicitely set a constraint for an edge
				layout.getConstraints(newButton).setConstraint( StringLayout.EAST, Spring.sum(xSpring, wSpring));
			.putConstraints()
				Creates constraints between two components with a spring object between them
				//										DEPENDENT component					REFERENCE component
				springLayout.putConstraint(SpringLayout.NORTH, button2, springBetween, SpringLayout.SOUTH, button1);
			
		Setting Constraints on the Entire Content Pane
			SpringLayout does not adjust the size of the container by default so the effect of pack() is as though the content pane were empty
			You can set constraints on the edges of the content pane using springs that control its size.
		Examples
			SpringLayout.Constraints constraints = layout.getConstraints(button);			// Get the Constraints for the Component
			Spring xSpring = Spring.constant(5,10,20); 										// Spring we’ll use for X
			Spring ySpring = Spring.constant(3,5,8); 										// Spring we’ll use for Y
			constraints.setX(xSpring); 														// Set the WEST edge constraint
			constraints.setY(xSpring); 														// Set the NORTH edge constrain
			Spring wSpring = Spring.constant(30,50,70); 									// Spring we’ll use for width
			Spring hSpring = Spring.constant(15); 											// Strut we’ll use for height
			constraints.setWidth(wSpring); 													// Set component width constraint
			constraints.setHeight(hSpring); 												// Set component height constraint
			constraints.setHeight(Spring.height(button1Component));							// Set the constraint height based on the height of component passed to Spring.height(comp) method
		Aligning a Component to Center
			// For Horizontal Alignment    
			layout.putConstraint(SpringLayout.HORIZONTAL_CENTER, component, 0, SpringLayout.HORIZONTAL_CENTER, contentPane);
			// For Vertical Alignment
			layout.putConstraint(SpringLayout.VERTICAL_CENTER, component, 0, SpringLayout.VERTICAL_CENTER, contentPane);
		Sources on Spring Layouts
			https://docs.oracle.com/javase/tutorial/uiswing/layout/spring.html
			https://stackoverflow.com/questions/21622148/how-can-i-center-align-a-component-with-springlayout

JMenu
	JMenuBar
		JMenuBar menuBar = new JMenuBar();
		containerObject.setJMenuBar(menuBar); //Adds the menu bar to the container (JFrame)
	JMenu
		JMenu fileMenu = new JMenu(“File”);
		fileMenu.addSeparator();
	JMenuItem
		You need the reference to the menu item to enable the program to react to the user clicking the item.
		JMenuItem openMenuItem = new JMenuItem(“Open”);
		Methods on JMenuItem
			Because the JMenu class is a subclass of JMenuItem, these methods also apply to JMenu objects
			void setEnabled(boolean b): If b has the value true, the menu item is enabled; false makes it.  The default state is enabled.
			void setText(String label): Sets the menu item label to the string stored in the label.
			String getText(): Returns the current menu item label
	JCheckBoxMenuItem
		JCheckboxMenuItem lineItem = new JCheckboxMenuItem(“Line”, true);
	JRadioButtonMenuItem
		JRadioButtonMenuItem item = new JRadioButtonMenuItem(“Curve”, true); //Radiobutton pressed
	Keyboard Shortcuts & Accllerators
		Shortcuts
			A shortcut is a unique key combination used to select a menu on the menu bar directly from the keyboard to display the drop-down menu.
			Example:
				fileMenu.setMnemonic(‘F’);	
		Accellerator
			An accelerator is a key combination that you can enter to select an item from a drop-down menu without having to go through the process of displaying the menu.
			KeyStroke class
				The javax.swing.KeyStroke class defines a keystroke combination. 
				The static method getKeyStroke() in the KeyStroke class returns the KeyStroke object corresponding to the arguments. 
				The first argument is a character in the keystroke combination and the second argument specifies one or more modifier keys.
				Only use uppercase letters to identify a letter for a keystroke. Lowercase letters select the non-alphabetic keys, such as the numeric keypad and the function keys. 
				The modifier keys are specified as a combination of single-bit constants that are defined in the InputEvent class that appears in the java.awt.event package.
			InputEvent class
				The InputEvent class defines constants that identify control keys on the keyboard and mouse buttons. 
				Constants
			 	SHIFT_DOWN_MASK, ALT_DOWN_MASK, META_DOWN_MASK, CTRL_DOWN_MASK. 
				Constants can be combinded:
					InputEvent.ALT_DOWN_MASK | InputEvent.CTRL_DOWN_MASK
				Note: manually import InputEvent from awt or Eclipse will mark getKeyStroke as deprecated
					import static java.awt.event.InputEvent.*;
				
			Accellerator Example:
				lineItem.setAccelerator(KeyStroke.getKeyStroke(‘L’, InputEvent.CTRL_DOWN_MASK));
	
Events
	Description
		The signals that a program receives from the operating system as a result of your actions are called events. 
		Each event that the program does recognize is associated with one or more methods.
		When the event occurs the appropriate methods are called automatically. 
		A window-based program is called an event-driven program because the sequence of events created as a result of your interaction with the GUI drives and determines what happens in the program.
	Overview
		Source of the Event (Source Object)
			An event always have a source object. A JButton for example.
		Event Object (ActionEvent object)
			Any event that is passed to a Java program is represented by a particular event object
		Target for an Event (Listener object)
			A listener object that has previously registered an interest in this kind of event — a listener object being simply an object that listens for particular events. 
			A listener object can listen for events for a particular object — just a single button, for example — or it can listen for events for several different objects 
		Event handling method
			 The ActionEvent object is passed as an argument to the method that is to handle the event.
	Low Level vs Semantic Events
		Low Level events
			System-level events: mouse movement, window state change, window resize, keyboard pressed
			.getSource() method that returns the source of an event as type Object
			java.awt.events classes:
				FocusEvent
				MouseEvent
				KeyEvent
				WindowEvent
				... there are many more 
		Semantic events
			Specific GUI component-level events:  selecting a button by clicking it to cause some program action or adjusting a scrollbar. 
			They originate, and you interpret them, in the context of the GUI you have created for your program. 
	Enable Event directly for an object
		Description
			Enable event if you want an object to handle some of its own events, although you can achieve the same result using a listener.
		Note
			There are masks for component events represented by objects of the class ComponentEvent and for container events. 	
		Window Class Methods to handel Component Events
			processEvent(AWTEvent e) 
				This is called first for any events that are enabled for the component. 
				If you implement this and fail to call the base class method, none of the methods for specific groups of events are called.
			processWindowFocusEvent( WindowEvent e) 
				This is called for any window focus events that arise as long as such events are enabled for the window.
			processWindowStateEvent( WindowEvent e) 
				This is called for events resulting from the window changing state.
			processFocusEvent(FocusEvent e) 
				This is called for focus events, if they are enabled for the component.
			processKeyEvent(KeyEvent e) 
				This is called for key events, if they are enabled for the component.
			processMouseEvent(MouseEvent e) 
				This is called for mouse button events, if they are enabled for the component.
			processMouseMotionEvent(MouseEvent e) 
				This is called for mouse move and drag events, if they are enabled for the component.
			processMouseWheelEvent(MouseWheelEvent e) 
				This is called for mouse wheel rotation events, if they are enabled for the component.
		Process
			0. create object (for example a JFrame)
			1. enableEvents(EVENT_TYPE_MASK)
			2. @override processEvent method
			3. identify eventID to determine action
			4. call super process method for other listeners
			Example
				instance.enableEvent(EVENT_TYPE_MASK);
				protected void processEVENT_TYPE(EVENT_TYPE eventObject){
					if (eventObject.getID==EVENT_TYPE.EVENT_ACTION) {
						...implement action for the event
						}
					super.processEVENT_TYPE(eventObject);
					}
	Event Listener
		Description
			A class that defines an event listener must implement a listener interface. 
			All event listener interfaces extend the interface java.util.EventListener. 
			This interface doesn't declare any methods, though — it's just used to identify event listener objects. 
			You can use a variable of type EventListener to hold a reference to any kind of event listener object.
		Semantic Listeners and Low-Level Listeners
			Low-Level Listener Interfaces
				A class must implement all methods (even if empty) of a listener interface to be able to use it
				List of Low-Level Interfaces
					WindowListener
					WindowFocusListener
					WindowStateListener
					MouseListener
					MouseMotionListener
					MouseWheelListener
					KeyListener
					FocusListener
			Adapter Classes
				An adapter class is a term for a class that implements a listener interface with methods that have no content, so they do nothing.
				Adapter classes must be extended to
				It is very important to use the @Override annotation when you are using adapter classes
				List of Adapter Classes:
					MouseAdapter
					MouseInputAdapter
					MouseMotionAdapter
					WindowAdapter
					KeyAdapter
					FocusAdapter
			Semantic Listeners
				Semantic events relate to operations on the components in the GUI for your program. Different kinds of components can produce different kinds of semantic events. 
				ActionEvent
					ActionEvent is generated when you perform an action on a component such as clicking on a menu item or a button. 
						Buttons: JButton, JToggleButton, JCheckBox
						Menus: JMenuItem, JMenu, JCheckBoxMenuItem, JRadioButtonMenuItem
				ItemEvent
					ItemEvent occurs when a component is selected or deselected
						Buttons: JButton, JToggleButton, JCheckBox
						Menus: JMenuItem, JMenu, JCheckBoxMenuItem, JRadioButtonMenuItem
				AdjustmentEvent
					AdjustmentEvent is produced when an adjustable object, such as a scrollbar, is adjusted.
						Scrollbar: JScrollbar
		Process of creating EventListeners
			Create Source Object -> make class implement Listener interface -> add listener to object -> implement event process method
			1. Register the component with Listener
				object.addXXXListener(ObjectThatImplementsXXXListener);
			2. Create event handling code
				2.1. Within class
					Class must implement xxxListener (ActionListener) or extend to Adapter
				2.2. Other class
					External class must implement ActionListener or extend to Adapter
				2.3. Anonymous class
					object.addActionListener(new ActionListener(){ .... code here ....}  )
	Action Objects
		Description
			An Action is an object of any class that implements the javax.swing.Action interface
			This interface declares methods that operate on an Action object — for example, storing properties relating to the action, enabling it, and disabling it. 
			The Action interface extends to the ActionListener interface, so an Action object is a listener as well as an action.
		Adding Action as arguments
			Some Swing components (JMenu, JToolbar) have an .add() method that accepts an argument of type Action. 
			The method creates a component from the Action object that is automatically of the right type. 
			You can add the very same Action object to both a menu and a toolbar.
			Because the Action object is its own listener, you automatically get both the menu item and the toolbar button supported by the same action.
		Action Properties
			Properties are items of information that relate to a particular object and are stored as part of the object. Often stored in a map with key:value pairs
			The Action interface has provision for storing several basic standard properties that relate to an Action object. Keys are String
			Properties
				NAME: A String object that is the label for a menu item or a toolbar button.
				SMALL_ICON: A javax.Swing.Icon reference to a small icon for a menu item (typically a javax.Swing.ImageIcon object).
				LARGE_ICON_KEY: An Icon reference to a large icon for a toolbar button (typically an ImageIcon object).
				SHORT_DESCRIPTION: A String object that is a tooltip.
				LONG_DESCRIPTION: A String object that is a context-sensitive help message.
				ACCELERATOR_KEY: A javax.swing.KeyStroke object that represents a key combination is the accelerator for the action.
				DISPLAYED_MNEMONIC_INDEX_KEY: An Integer object indicating where in the NAME property value the decoration (which is an underline) for a mnemonic should be rendered. 
				MNEMONIC_KEY: An Integer that corresponds to a KeyEvent key code.
				SELECTED_KEY: A Boolean object that records the selected or unselected state.
				ACTION_COMMAND_KEY: A String object that is the command string for the action
		Action Methods
			void putValue(String key,Object value)
				Stores the object value associated with the key constant key in the action object. 
				Example to store String object "Save all" as NAME value
					putValue(NAME, “Save All”);
			Object getValue(String key)
				This retrieves the object from the map corresponding to the key key. 
				Example to retrieve a small icon from an action object, action:
					ImageIcon lineIcon = (ImageIcon)(action.getValue(SMALL_ICON));
			boolean isEnabled()
				This returns true if the action object is enabled and false otherwise.
			void setEnabled(boolean state)
				This sets the Action object as enabled if state is true and disabled if it is false. 
				This operates on BOTH the toolbar button and the menu item if they have been created using the same Action object.
			void addPropertyChangeListener(PropertyChangeListener listener)
				This adds the listener passed as an argument, which listens for changes to properties such as the enabled state of the object. 
				This is used by a container for an Action object to track property changes.
			void removePropertyChangeListener(PropertyChangeListener listener)
				This removes the listener passed as an argument. This is also for use by a Container object.
		AbstractAction javax.swing
			The javax.swing package defines the AbstractAction class that already implements the Action interface. 
			If you EXTEND this class to create your own action class, you get a basic infrastructure for free, including the ability to handle events.











Source
	Detailed description of creating JFrame, components, layout managers
		Horton, Chapter 17, p661 - Creating Windows
		Horton, Chapter 18, pxxx - Handling Events
	Official decriptions
		https://docs.oracle.com/javase/tutorial/uiswing/layout/spring.html
		https://docs.oracle.com/javase/7/docs/api/javax/swing/SpringLayout.html
		https://docs.oracle.com/javase/tutorial/uiswing/layout/visual.html
	Great, simple tutorial of event handling
		https://www.javatpoint.com/event-handling-in-java
	Sample of using Action objects for buttons
		https://docs.oracle.com/javase/tutorial/uiswing/misc/action.html

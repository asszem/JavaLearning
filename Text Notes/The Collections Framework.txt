HashMaps
	Hashing process
		Description
			The implementation of a map in the Java collections framework that is provided by the HashMap<K,V> class.
			It creates an array in which it stores key and object pairs of type K and V respectively.
			The index to this array is produced from the key object by using the hashcode for the object to compute an offset into the array for storing the key/object pair. 
		Bucket
			An entry in the table that is used to store key/value pairs is called a bucket. 
			The hashcode produced from a key selects a particular bucket in which the key/value pair should be stored. 
			Hashing determines where objects are placed in a hash map.
		Collision
			Description
				Every key must be unique, but not every hashcode must be unique
				When two or more keys produce the same hash value, it's called a collision.
				A HashMap<> object deals with collisions by storing all the key/object pairs that have the same hash value in a linked list.
			Process of resolving a collision:
				Step 1.  The key is hashed to find the location where the key/object pair should be. 
				Step 2.  The linked list then has to be searched to sort out the key you are searching on from all the others that have the same hash value. 
			How to avoid collision?
				The price of reducing the possibility of collisions in a hash table is having plenty of empty space in the table.
	HashCode() method
		The Default method
			By default, the hashCode() method is used for the key object. 
			This is inherited in all classes from Object so this is the method that produces the basic hashcode unless the hashCode() method is redefined in the class for the key. 
			The HashMap<> class does not assume that the basic hashcode is adequate.
			To try to ensure that the hashcode that is used has the characteristics required for an efficient map, the basic hashcode is further transformed within the HashMap<> object.
		How the default Object hashCode() method works?
			It usually uses the MEMORY ADDRESS where an object is stored to produce the hash value, so distinct objects always produce different hash values. 
			Probem
				Because of hashcode generated by memory address, different objects that have identical data produce different hash values, so they can't be compared
				A key object hash code will never be the same of another key object's hashcode, even if the data in the two key objects are exactly the same.
				Example
					Create a key object to store the key in a HashMap. It will have a hashCode created based on its memory address.
					Enter a search term from keyboard to create a new key object from the entered data. The new key object will have different hash code than the key object in the HashMap.
			Solution
				Create a hashcode from the instance variables of the object. 
				Then, by comparing the hashcode produced from the data members of the new key object with the hashcodes for the key objects in the hash map, you are able to make a match.
	Using Objects as Keys
		Override equals()
			For objects of one of your own classes to be usable as keys in a hash table, you MUST override the equals() method of the Object class.
			The equals() method is used by methods in the HashMap<> class to determine when two KEYS are equal.
			The overridden equals() method should return true when two different objects contain identical data values.
		Override hashCode()
			You can also override the default hashCode() method, which returns the hash value for the object as type int. 
			Your hashCode() method should produce hashcodes that are reasonably uniform over the possible range of keys and is generally unique for each key.
			Ideal hashcode
				Has a strong probability of being unique to the object
				The hashcodes produced for the range of different objects should be as widely distributed across the range of int values as possible.
		How to generate ideal hashcodes?	
			Combine the values of all the data members in an object to produce the hashcode.
			The following mehtod should produce a reasonable distribution of values that have a good probability of being different for different objects
			Steps
				1. Produce an integer corresponding to each data member 											- int fieldHash1=fieldName.hashcode()
				2. Multiply each of the integers corresponding to the data members by a different prime number		- 7*fieldHash1 
				3. Sum the results. 																				- 7*fieldHash1 + 13 * fieldHash2 + 17* fieldHash3....
			Generating hashCodes from String
				The String class hashCode() implementation produces good hashcode values that are the same for identical strings.
			Generating hashCodes form Integers/Floating-points
				Integers are OK.
				Floating-point data members need a bit of judgment. 
					If they have a small range in integer terms, you need to multiply them by a value that's going to result in a unique integer when they are cast to type int. 
					If they have a very large range in integer terms you might need to scale them down.
			Generating hashCodes for another class Objects
					Wherever a data member is an object of another class rather than a variable of one of the basic types, you need to implement the hashCode() method for that class.
			Example:
				public int hashCode() {
				return 7 * firstName.hashCode() + 13 * surname.hashCode() + 19*age; }						//Generates hashcode based on first name and last name (strings) and age (integer)
		Example
			@Override //Equals																						
				public boolean equals(Object comparedToPerson) {											//Uses the compareTo method to determine whether two Person object is same
					return compareTo((Person)comparedToPerson) == 0; }										//Evaulates TRUE if the compareTo method returns 0
			@Override
				public int hashCode() {
					return 7 * firstName.hashCode() + 13 * surname.hashCode(); }							//Generates hashcode based on first name and last name
			@Override																						//Compares 'Person' objects by surname String field value
				public int compareTo(Person comparedToPerson) {
					int result = this.surname.compareTo(comparedToPerson.surname);							//compares surnames 
					return result == 0 ? this.firstName.compareTo(comparedToPerson.firstName) : result; }	//compares firstnames is surnames equals
	Creating a HashMap<K,V> object
		Constructors
			HashMap()
				The default capacity is 16 objects, and the default load factor is 0.75
				HashMap<String,Person> theMap = new HashMap<>();
			HashMap(int capacity)
				HashMap myMap<String,Person> = new HashMap<>(151); 			//use prime numbers for capacity
			HashMap(int capacity, float loadfactor)
				HashMap<String,Person> aMap = new HashMap<>(151, 0.6f);		//more efficient, but will have more unoccupied space
			HashMap(Map<? extends K, ? extends V> map) 
				Creates a map with the mappings, capacity and load factor of the Map (any map, not hashmap!) object passed as the argument.
		Capacity
			The capacity for a map is simply the number of key/object pairs it can store. 
			The capacity value of the map is combined with the hashcode for the key that you specify to compute the index that determines where an object and its key are to be stored. 
			The capacity increases automatically as necessary, but this is a relatively time-consuming operation. 
			To make this computation produce a good distribution of index values, you should ideally use prime numbers for the capacity of a hash table when you specify it yourself.
			You must always have spare capacity in a map for efficient operation. 
			With too little spare capacity, you have an increased likelihood that keys generate the same bucket index, so collisions become more likely.
		LoadFactor
			The load factor is used to decide when to increase the size of the hash table. 
			When the size of the table reaches a value that is the product(szorzat) of the load factor and the capacity (0.6*151)
			The capacity is increased automatically to twice the old capacity plus on the plus one ensuring it is at least odd, if not prime. 
			The default load factor of 0.75 is a good compromise.
			Example:
				Create a map with a 60% load factor works a bit more efficiently than the default, but at the expense of having more unoccupied space. 
					Capacity: 151
					LoadFactor: 60% 
					Product of capacity and load factor= 151 * 0,6 = 90
				When 90 objects have been stored, the capacity is increased to 303
					New capacity: twice the old capacity plus one: 2*151 = 302 + 1
	Storing, Retrieving, and Removing Objects 
		Storing values to a Map 
			Put single value
				V put(K key, V value)
				Stores the object value in the map using the key specified by the first argument. 
				Value REPLACES ANY EXISTING OBJECT ASSOCIATED WITH KEY, and a reference to the previous object for the key is returned. 
				If no object was previously stored for key or the key was used to store null as an object, null is returned.
				Example
					aMap.put("key", 12345);  //if 'key' was already used, its value will be replaced!
			Put multiple values
				void putAll(Map<? extends K,? extends V> map)
				Transfers all the key/object pairs from map to the current map, replacing any objects that exist with the same keys.
				Does not return (void) anything.
		Retrieving
			V get(Object key)
			Returns the object stored with the same key as the argument. If no object was stored with this key or null was stored as the object, null is returned. 
			Note that the object remains in the map. This is not a Stack!
		Removing
			V remove(Object key): Removes the entry associated with key if it exists and returns a reference to the object. 
			A null is returned if the entry does not exist, or if null was stored using key.
	Processing ALL elements
		Set<K> keySet()
			Returns an object containing all the keys from the map. Can iterate with collection based for-loop
				for(String key : aMap.keySet()) { System.out.println(key); }
		Set<Map.Entry<K,V>> entrySet()
			Returns an object containing the key/object pairs — each pair being an object of type Map.Entry<K,V>.
			Need to iterate to get the methods for each entry
				Set<Map.Entry<K, V>> allEntrySet= aMap.entrySet();
				for (Map.Entry<K, V> currentEntry : allEntrySet) { System.out.println(currentEntry.getKey() + ":" + currentEntry.getValue()); }
				currentEntry.getKey; currentEntry.getValue; currentEntrySetValue(12345);
			A Map.Entry<> object also needs
				an equals() method for comparisons with another Map.Entry<> object passed as an argument 
				and a hashCode() method to compute a hashcode for the Map.Entry object.
		Collection<V> values()
			Returns an object containing all the values stored in the map. Can iterate with collection based for-loop 
				for(Integer i : collection) { System.out.println(i); }


Why is Vector() obsolete?
	http://stackoverflow.com/questions/1386275/why-is-java-vector-class-considered-obsolete-or-deprecated

Why the default hashCode() method needs to be overwritten to use the fields of a class to generate hashcodes when storing objects to files?
	Problem:
		WARNING Beware of the default hashCode() method in the Object class when storing maps in a file. 
		The hashcodes are generated from the address of the object, so the hashcode for a key is entirely dependent on where it is stored in memory. 
		Getting a key back from a file in exactly the same place in memory where it was originally stored is almost impossible. 
		When reading a map back from a file, the hashcode generated from a key now used to access the map is different from what was originally produced when stored the object with the key
		Because of this, you will never find the entry in the map to which it corresponds.
	Solution
		You must override the default hashCode() method so that the hashcodes for keys are produced from the data members of the key objects.
		This ensures that the hashcode for a given key is always the same. 
	Source
		Horton, p. 562

Sources for Collections
	Horton Chapter 14, p517





***Summary***
/write this part at the end of the chapter when I know what the most improtant parts are

	type argument
	type parameter
	type safe
	upper boundary
	lower boundary
	wildcard arguments / bounded wildcards
	generic methods

***Details***

General Forms
	Generic Class
		class class-name<type-param-list>
			class MobilePhones<T, V, Users<T>>
	Upper Bounded Class
		class class-name<T extends superclass>
	Generic Method
		<access modifier> <type-param-list> return-type method-name(param-list) {method body...}
			Example: 
				public static <T extends Comparable<T>, V extends T> boolean thisIsTheName(T firstParameterOfTypeT, V secondParameterOfTypeV)

Generic or parameterized types
	A generic (or parameterized) type is a class or interface type definition that has one or more TYPE PARAMETERS. 
	You define an actual class or interface type from a generic type by supplying a TYPE ARGUMENT for each of the type parameters that the generic type has.
	Type safe - A class that always prevents you from accidentally adding objects of the wrong type

Generic Class Definition 
	The type parameter goes between <> after class/interface/(method) name
	Occurrences of the type parameter name in the definition of a generic type are called TYPE VARIABLES because
	they are replaced by a value that is a type in a similar way to how method parameters are replaced by the arguments that you supply.
	Example:
		public class LinkedList<T> {              // T is the type variable or type parameter
			// Generic type definition...
		}

Generic Class Implementation
	Example
		public class LinkedList<T> {
			public LinkedList(T item) {...} 			//Constructor
			public LinkedList(T[] items) {...}			//Constructor
			public void addItem(T item) {...}			//Method
			public T getFirst() {...}		  		    //Method
			public T getNext() {...}				    //Method
			public ListItem(T item) {...}				//Method
			T item; 									//Instance variable

Generic Class Instantiaton
	When you create a particular type from the generic type definition by supplying an argument value for T ('String' for example)
	the argument is substituted for every occurrence of T in the generic type specification.
	The compiler uses the type argument String that you supplied to replace every instance of the type variable, T
	in the generic type definition to arrive at the notional (képzeletbeli) class type definition for LinkedList<String>.
	The angled brackets<> without a type specification between are often referred to as the DIAMOND OPERATOR
	Example:
		LinkedList<String> stringsOnly = new LinkedList<>(); 	//All 'T' will be replaced to 'String'
			public LinkedList(String item) {...} 				//Constructor
			public LinkedList(String[] items) {...}				//Constructor
			public void addItem(String item) {...}				//Method
			public String getFirst() {...}						//Method
			public String getNext() {...}						//Method
			public ListItem(String item) {...}					//Method
			String item;										//Instance variable
	Example 2
		LinkedList<LinkedList<String>> linkedLists = new LinkedList<>();  //The type argument here is another generic type class: LinkedList<String>
	Example 3
		LinkedList<String> strings = new LinkedList<String>(); 	//this works also, but the second <String> part is redundant
																//Netbeans will give a warning of redundant type argument
	Example 4
		LinkedList<Double> temperature = new LinkedList<>(); 	//use the 'Double' wrapper class to store double type primitive value
	Example 5
		LinkedList<T, V> ...						//multiple type parameters can be used
			LinkedList<String, Double> obj1;
			LinkedLIst<Integer, Integer> obj2;		//type arguments can be the same

Type Erasure & Leftmost Bound
	Type Erasure
		Type Erasure is the process when all occurrences of the type variable T are eliminated and replaced by type 'Object' when instantiating LinkeList<Point> polyline;
		You end up with a notional(képzeletbeli) class where all 'T' replaced to 'Object'
		The type parameter following the class name ('T') in the original generic type definition has been removed, and all
		occurrences of the type variable 'Point' within the class definition have been replaced by type Object. 
	Why 'Object'?
		Type Object is chosen by the compiler to replace the type variable because type Object is the ultimate superclass class from which type Point is derived.
		The type that the compiler selects to replace a type variable is the LEFTMOST BOUND of the type variable. 
	What's the point and why not just define Object anyways?
		To ensure COMPILE-TIME TYPE SAFETY for the compiler. 
			When you use an object of type LinkedList<Point> in your code, the compiler checks that you use it only to store objects of type Point
			The compiler flags any attempt to store objects of other types as an error. 
			When you call methods for an object of type LinkedList<Point>, the compiler ensures that you supply references only of type Point
			where the original method parameter was specified as the type parameter
	What is LEFTMOST BOUND?
		Type Object is the DEFAULT LEFTMOST BOUND that applies to any class type because all classes have type Object as their ultimate superclass. 
	Why and how specify different leftmost bound?
		<TBW>

Scope of Type parameter
	The scope of a type parameter is the entire generic class definition but excluding any STATIC MEMBERS or INITIALIZERS in the class.

Static Methods
	Static methods cannot have parameters or return types that correspond to a class type parameter
	and you must not use the class type parameters in the bodies of static method definitions.
		Example 1 - Bad
			static T boolean notGood(T input) {...
		Example 2 - Good
			static <V> V (V input) {...

Static Fields
	All types produced from a given generic type share the same runtime type. Consequently they do not have their own independent static fields. 
	Any static fields you define in a generic type are shared among all instances of it. 
	Static fields in generic type definitions are best avoided.


Upper Bound & Lower Bound
	Upper bound <T extends UpperBoundClass>
		T can be replaced only by superclass or subclasses of superclass. 
		The upper bound declares the superclass from which all type argumetns must be derived.  Inclusive upper limit, as superclass is included.
		The EXTENDS keyword must be used, regardless of whether the type parameter bound is a class or an interface
		Example:
			class MobilePhone<T, V extends T> {...			//V must be either type T or subclass of T
		Example 2:
			class LinkedList<T extends Serializable> implements Serializable {	  //the type paramter class must implement serializable as well, so everything can be serialized
		Example 3: 
			class MyType<T extends FancyClass & Serializable & MyInterface>   	//Multiple bounds: FancyClass class and Serializable and MyInterface interface

	Lower bound <T super LowerBoundClass>
		Only LowerBoundClass and it's super classes are acceptable


Runtime Class Type
	All types that you generate from a given generic type share the same class name at run time.
	Because all types that you produce from a generic type have the same runtime type, you cannot use the INSTANCEOF operator to test for such types.

Implementing Iterable<T>
	Implementing Iterable<T> will make the class eligible to run the collection based for-loop
	An iterator is a one-time use object so you need to recreate it each time.
	Steps
		1. The class must be generic and implement Iterable<T>
		2. A public Iterator<T> iterate() method must @Override (implement) the method from the Iterable<T> interface. This must return an Iterator<T> type object
		3. A subclass needs to be created, that implements Iterator<T> interface
		4. Two methods from Iterator<T> must be implemented in this subclass: HasNext and T next()
		5. A collection-based for loop can now be called for the instances of the generic class. 
	Notes
		Netbeans will create skeleton for mandatory implementations
		When overriden methods not fully implemented yet, a runtime exception can be thrown

Naming convention
	The convention in Java is to use single letters as type parameter names. 
	So it can be differentiated from a class name (starts with Capital) or variable/method name (starts with lowerCase)
		T - type parameter
		ClassName - class name
		methodName() - method name
		variableName - variable name
		FINAL_VARIABLE - final variable name
	Typicall type parameters
		T is used to indicate a parameter is a TYPE (String, Point, MobilePhone, etc)
		N is used for a parameter that is a NUMERICAL value
		K is used for a parameter that is a KEY
		V is used for a type parameter that is a VALUE
		E is used for a parameter that is an ELEMENT

Sources
	Horton, Chapter 13
	Herbert Schildt, Beginners Guide, 6th Edition, Chapter 13, Generics
